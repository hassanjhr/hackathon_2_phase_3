<!--
Sync Impact Report:
Version: 1.0.0 → 2.0.0
Rationale: MAJOR bump — Phase-III adds 4 new principles (VII–X) that
fundamentally extend the architecture with agent-first AI, MCP tools,
stateless backend reconstruction, and conversation persistence requirements.
Existing principles I–VI remain unchanged.

Modified Principles: None (I–VI preserved verbatim)
Added Sections:
  - Principle VII: Agent-First Architecture
  - Principle VIII: MCP Tool Exclusivity
  - Principle IX: Stateless Backend with Context Reconstruction
  - Principle X: Conversation Persistence
  - System Separation Standard (new section)
  - Phase-III Technology Additions (appended to Technology Stack)
Removed Sections: None

Templates Status:
  - ⚠ .specify/templates/plan-template.md — Constitution Check needs
      principles VII–X added (manual follow-up)
  - ⚠ .specify/templates/spec-template.md — Security Requirements section
      should reference MCP tool ownership validation (manual follow-up)
  - ⚠ .specify/templates/tasks-template.md — Foundational phase should
      include MCP tool setup and conversation store tasks (manual follow-up)

Follow-up TODOs:
  - Update plan-template.md Constitution Check with principles VII–X
  - Update spec-template.md Security Requirements with MCP ownership rules
  - Update tasks-template.md Foundational phase with MCP/conversation tasks
-->

# Todo Full-Stack Web Application Constitution

## Core Principles

### I. Spec-First Development

All behavior MUST be defined in written specifications before any implementation begins.

**Rules:**
- Every feature requires a complete spec document before planning or coding
- Specs MUST include acceptance criteria, API contracts, and data models
- No implementation may proceed without an approved spec
- Changes to behavior require spec amendments first

**Rationale:** Spec-first development ensures clarity, prevents scope creep, enables
traceability, and provides a single source of truth for all stakeholders including
judges and reviewers.

### II. Security by Default

Authentication and authorization MUST be enforced at every layer of the application.

**Rules:**
- All API endpoints MUST require valid JWT authentication
- JWT tokens MUST be verified server-side using a shared secret
- User identity MUST be extracted from JWT, never from request body
- URL user_id parameters MUST match authenticated user_id
- Requests without valid tokens MUST return 401 Unauthorized
- Token expiration MUST be respected and enforced
- No frontend or backend logic may bypass authentication checks

**Rationale:** Security by default prevents data breaches, ensures compliance with
privacy requirements, and builds trust. Authentication must be non-negotiable and
enforced at the infrastructure level, not as an afterthought.

### III. User Data Isolation

Users MUST only access their own data; cross-user data access is strictly prohibited.

**Rules:**
- Task ownership MUST be enforced at the database query level
- All queries MUST filter by authenticated user_id
- Database models MUST include user_id foreign keys
- API responses MUST only contain data belonging to the authenticated user
- No shared or public tasks allowed in basic implementation
- MCP tools MUST validate user ownership before executing any mutation

**Rationale:** User data isolation is a fundamental privacy and security requirement.
Enforcing isolation at the database layer prevents bugs, misconfigurations, or
malicious attempts from exposing user data.

### IV. Reproducibility

Every feature MUST be traceable to written artifacts and reproducible by others.

**Rules:**
- All features MUST have corresponding spec, plan, and task documents
- All implementation decisions MUST be documented in ADRs when architecturally significant
- All user interactions MUST be recorded in PHRs (Prompt History Records)
- Generated code MUST be clean, readable, and maintainable
- Project structure MUST follow Spec-Kit Plus conventions

**Rationale:** Reproducibility enables review, audit, learning, and handoff. The project
must be judge-ready, meaning any reviewer can understand what was built, why, and how,
by reading the artifacts.

### V. Automation-First

All implementation MUST be generated by Claude Code agents; manual coding is prohibited.

**Rules:**
- No manual code writing allowed
- All code MUST be generated through Claude Code specialized agents
- Agent selection MUST match domain expertise:
  - `auth-security-handler` for authentication
  - `nextjs-ui-builder` for frontend
  - `neon-db-manager` for database
  - `fastapi-backend-dev` for backend API
- Workflow MUST follow: Spec → Plan → Tasks → Implement
- All agent interactions MUST be documented
- Manual feature additions outside the specification workflow are prohibited

**Rationale:** Automation-first demonstrates the power of agentic development, ensures
consistency, reduces human error, and validates the Spec-Kit Plus methodology for
real-world projects.

### VI. Production Realism

The application MUST use production-grade technologies and patterns, not toy implementations.

**Rules:**
- Real database: Neon Serverless PostgreSQL (not in-memory or SQLite)
- Real authentication: Better Auth with JWT (not hardcoded users)
- Real API: FastAPI with proper REST conventions (not mock endpoints)
- Real frontend: Next.js 16+ App Router (not static HTML)
- Proper error handling with HTTP status codes (401, 403, 404, 422, 500)
- Environment-based configuration (`.env` files, no hardcoded secrets)

**Rationale:** Production realism ensures the project demonstrates real-world skills,
not just academic exercises. The application should be deployable and maintainable,
showcasing industry-standard practices.

### VII. Agent-First Architecture

All conversational task operations MUST be executed through AI agents; direct
API-to-database paths are prohibited for chat-driven features.

**Rules:**
- The AI agent MUST be the sole entry point for all natural-language task operations
- Agents MUST use the OpenAI Agents SDK for orchestration
- Agents MUST NOT access the database directly; all data mutations and queries
  MUST flow through MCP tools
- The system separation MUST follow:
  `UI (Chat Interface) → Agent Runner → MCP Tools → Database`
- Agent responses MUST be grounded in MCP tool outputs, not fabricated

**Rationale:** Agent-first architecture enforces a clean separation of concerns where
AI reasoning is decoupled from data access. This makes the system auditable, testable,
and prevents the agent from bypassing business rules or ownership checks.

### VIII. MCP Tool Exclusivity

All task mutations MUST be executed strictly via MCP (Model Context Protocol) tools;
no direct database access from agents or ad-hoc queries are permitted.

**Rules:**
- Every data operation (create, read, update, delete) available to the agent
  MUST be exposed as a named MCP tool
- MCP tools MUST be deterministic, stateless, and independently testable
- Each MCP tool invocation MUST validate authenticated user ownership before executing
- MCP tool inputs and outputs MUST have defined schemas
- All AI-initiated actions MUST be logged and traceable to a specific tool call
- New data operations require a new MCP tool; agents MUST NOT construct raw queries

**Rationale:** MCP tool exclusivity creates a narrow, auditable interface between
AI reasoning and data mutation. Every action the agent can take is explicitly defined,
validated, and logged — eliminating prompt-injection paths to the database and
ensuring all operations respect user isolation.

### IX. Stateless Backend with Context Reconstruction

Backend services MUST remain stateless; conversation context MUST be reconstructed
from stored messages for each request.

**Rules:**
- The backend MUST NOT maintain in-memory conversation state between requests
- On each chat request, the backend MUST load the conversation history from
  the database and reconstruct the agent context
- Conversation messages MUST be stored with user_id, role, content, and timestamp
- The agent runner MUST receive the full reconstructed context on every invocation
- No server-side session objects or global state for conversations are permitted

**Rationale:** Stateless backend design ensures horizontal scalability, crash
resilience, and deployment simplicity. Reconstructing context from persisted messages
guarantees that no conversation data is lost on server restart or load-balancer
re-routing.

### X. Conversation Persistence

All user and assistant messages MUST be persisted before returning responses.

**Rules:**
- The user message MUST be stored in the database before the agent processes it
- The assistant response MUST be stored in the database before returning to the client
- Each message record MUST include: user_id, conversation_id, role (user/assistant),
  content, and created_at timestamp
- Conversation history MUST be retrievable per user per conversation
- Message persistence failures MUST prevent the response from being returned
  (fail-safe, not fail-silent)

**Rationale:** Persisting every message ensures conversation continuity across
sessions, enables audit trails for AI actions, supports context reconstruction
for the stateless backend, and prevents data loss.

## System Separation Standard

Phase-III introduces a strict four-layer separation for all chat-driven features:

```
┌─────────────────────┐
│  UI (Chat Interface) │  Next.js frontend — sends user messages
└──────────┬──────────┘
           │ HTTP POST /chat
           ▼
┌─────────────────────┐
│    Agent Runner      │  FastAPI endpoint — reconstructs context,
│  (OpenAI Agents SDK) │  invokes AI agent with MCP tools
└──────────┬──────────┘
           │ MCP tool calls
           ▼
┌─────────────────────┐
│     MCP Tools        │  Stateless functions — validate ownership,
│  (Todo CRUD, etc.)   │  execute DB operations, return results
└──────────┬──────────┘
           │ SQL via SQLModel
           ▼
┌─────────────────────┐
│     Database         │  Neon Serverless PostgreSQL
└─────────────────────┘
```

**Rules:**
- UI MUST NOT call MCP tools directly
- Agent Runner MUST NOT execute raw SQL
- MCP Tools MUST NOT hold state between invocations
- Database access MUST only occur through MCP tool implementations

## Technology Stack

**Mandatory Technologies (Phase I–II):**

| Layer | Technology | Version/Constraint |
|-------|-----------|-------------------|
| Frontend | Next.js | 16+ (App Router) |
| Backend | Python FastAPI | Latest stable |
| ORM | SQLModel | Latest stable |
| Database | Neon Serverless PostgreSQL | Cloud-hosted |
| Authentication | Better Auth | JWT-based |
| Spec System | Spec-Kit Plus | Latest |

**Phase-III Technology Additions:**

| Layer | Technology | Version/Constraint |
|-------|-----------|-------------------|
| AI Agent SDK | OpenAI Agents SDK | Latest stable |
| Tool Protocol | MCP (Model Context Protocol) | Server architecture |
| AI Model | OpenAI GPT (via Agents SDK) | As configured |

**Technology Constraints:**
- Frontend and backend MUST be separate services
- API communication MUST use REST over HTTP
- Database MUST be Neon PostgreSQL (no substitutions)
- Authentication MUST use Better Auth (no custom auth)
- All dependencies MUST be declared in package.json / requirements.txt
- AI agent orchestration MUST use OpenAI Agents SDK (no custom agent loops)
- Tool execution MUST use MCP server architecture (no ad-hoc function calls)

**Rationale:** Standardizing the technology stack ensures consistency, enables agent
specialization, and demonstrates proficiency with modern, industry-relevant tools.

## Security Requirements

**Authentication Flow:**

1. User logs in on Next.js frontend
2. Better Auth validates credentials and issues JWT token
3. Frontend includes token in `Authorization: Bearer <token>` header for all API calls
4. FastAPI backend extracts and verifies JWT signature using shared secret
5. Backend decodes token to extract user_id
6. Backend filters all queries by authenticated user_id

**MCP Tool Security (Phase-III):**
- Every MCP tool invocation MUST receive the authenticated user_id
- MCP tools MUST verify user ownership of the target resource before mutating
- Agent-generated tool calls MUST be logged with user_id, tool name, and parameters
- The agent MUST NOT be able to override or fabricate user_id

**Security Standards:**
- JWT secret keys MUST be stored in `.env` files, never hardcoded
- Token verification MUST happen on every protected endpoint
- User identity MUST come from verified JWT, not request parameters
- Failed authentication MUST return 401 Unauthorized
- Authorization failures MUST return 403 Forbidden
- HTTPS MUST be used in production environments

**Prohibited Practices:**
- Trusting user_id from request body or URL without JWT verification
- Bypassing authentication for "convenience" during development
- Storing passwords in plain text
- Exposing JWT secrets in code or logs
- Allowing unauthenticated access to any user data
- Allowing agents to access the database without going through MCP tools
- Allowing agents to fabricate tool outputs or skip tool validation

## Development Workflow

**Mandatory Workflow Stages:**

1. **Specification** (`/sp.specify`)
   - Define feature requirements clearly
   - Include acceptance criteria
   - Specify API contracts and data models
   - Get user approval before proceeding

2. **Planning** (`/sp.plan`)
   - Use appropriate specialized agent based on domain
   - Generate architectural plan
   - Identify dependencies and risks
   - Document significant decisions

3. **Task Breakdown** (`/sp.tasks`)
   - Break plan into testable, atomic tasks
   - Assign tasks to appropriate agents
   - Define acceptance criteria for each task
   - Order tasks by dependencies

4. **Implementation** (`/sp.implement`)
   - Execute tasks using assigned agents
   - Follow TDD approach where applicable
   - Create PHRs for each implementation session
   - Validate against acceptance criteria

5. **Validation**
   - Test all endpoints with valid and invalid tokens
   - Verify authentication flow end-to-end
   - Check database queries for proper user filtering
   - Validate frontend functionality and responsiveness
   - Verify MCP tools are deterministic and stateless (Phase-III)
   - Verify conversation persistence round-trip (Phase-III)
   - Verify agent cannot bypass MCP tools (Phase-III)

**Agent Coordination:**

For features spanning multiple domains, follow this order:
1. Database schema (`neon-db-manager`)
2. Backend API (`fastapi-backend-dev`)
3. Authentication layer (`auth-security-handler`)
4. Frontend UI (`nextjs-ui-builder`)

**Quality Gates:**
- No task may be marked complete without passing acceptance criteria
- No feature may be merged without complete documentation trail
- No code may be deployed without authentication verification
- No manual code edits allowed (automation-first principle)
- No MCP tool may be deployed without ownership validation tests (Phase-III)

## Governance

**Amendment Process:**
- Constitution amendments require explicit user approval
- Version bumps follow semantic versioning:
  - MAJOR: Backward-incompatible principle changes
  - MINOR: New principles or sections added
  - PATCH: Clarifications, typo fixes, non-semantic changes
- All amendments MUST update dependent templates and documentation
- Amendment rationale MUST be documented in Sync Impact Report

**Compliance Verification:**
- All specs MUST reference applicable constitutional principles
- All plans MUST include constitution compliance checks
- All tasks MUST align with principle-driven requirements
- All PRs/reviews MUST verify constitutional compliance

**Enforcement:**
- Violations of security principles are blocking issues
- Violations of automation-first principle invalidate the project
- Violations of spec-first principle require rollback and re-specification
- Violations of agent-first or MCP-exclusivity principles require
  architectural remediation before feature can proceed (Phase-III)
- Violations of other principles require documented justification and remediation plan

**Living Document:**
- This constitution is the authoritative source for project standards
- When conflicts arise between constitution and other docs, constitution prevails
- Constitution should be consulted before making any architectural decisions
- Constitution should be updated when new patterns or constraints emerge

**Version**: 2.0.0 | **Ratified**: 2026-02-06 | **Last Amended**: 2026-02-09
